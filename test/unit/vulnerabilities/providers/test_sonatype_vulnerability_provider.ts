import {SonaTypeVulnerabilityProvider} from 'src/vulnerabilities/providers/sonatype_vulnerability_provider';
import {Package, PackageType} from 'src/packages/types';
import {corsFetch} from 'src/utils/cors_client';

jest.mock('src/utils/cors_client', () => ({
  corsFetch: jest.fn(),
}));

describe('SonaTypeVulnerabilityProvider (unit)', () => {
  let provider: SonaTypeVulnerabilityProvider;

  beforeEach(() => {
    provider = new SonaTypeVulnerabilityProvider(PackageType.NPM);
    jest.clearAllMocks();
  });

  describe('getCoordinatePkgMap', () => {
    it('should map packages to correct coordinates', () => {
      const pkgs: Package[] = [
        {name: 'foo', version: '1.0.0'},
        {name: 'bar', version: '2.1.3'},
      ];
      const map = (provider as any).getCoordinatePkgMap(pkgs);
      expect(map.get('pkg:npm/foo@1.0.0')).toEqual(pkgs[0]);
      expect(map.get('pkg:npm/bar@2.1.3')).toEqual(pkgs[1]);
    });
  });

  describe('buildRequestBody', () => {
    it('should build correct JSON string', () => {
      const coords = ['pkg:npm/foo@1.0.0', 'pkg:npm/bar@2.1.3'];
      const body = (provider as any).buildRequestBody(coords);
      expect(body).toBe(JSON.stringify({coordinates: coords}));
    });
  });

  describe('requestOptions', () => {
    it('should return correct fetch options', () => {
      const coords = ['pkg:npm/foo@1.0.0'];
      const opts = (provider as any).requestOptions(coords);
      expect(opts.method).toBe('POST');
      expect(opts.headers['Content-Type']).toBe('application/json');
      expect(opts.body).toBe(JSON.stringify({coordinates: coords}));
    });
  });

  describe('mapVulnerabilities', () => {
    it('should map Sonatype vulnerabilities to app model', () => {
      const raw = [
        {title: 'Vuln1', cvssScore: 7.0, cve: 'CVE-1'},
        {title: 'Vuln2', cvssScore: 3.5},
      ];
      const vulns = (provider as any).mapVulnerabilities(raw);
      expect(vulns[0]).toMatchObject({
        name: 'Vuln1',
        cvssScore: 7.0,
        cveId: 'CVE-1',
        severity: expect.any(String),
      });
      expect(vulns[1]).toMatchObject({
        name: 'Vuln2',
        cvssScore: 3.5,
        cveId: undefined,
        severity: expect.any(String),
      });
    });
    it('should return empty array for empty input', () => {
      expect((provider as any).mapVulnerabilities([])).toEqual([]);
      expect((provider as any).mapVulnerabilities(undefined)).toEqual([]);
    });
  });

  describe('dataFromSonaType', () => {
    it('should return empty array for empty coordinates', async () => {
      const result = await (provider as any).dataFromSonaType([]);
      expect(result).toEqual([]);
    });
    it('should call corsFetch and return parsed data', async () => {
      (corsFetch as jest.Mock).mockResolvedValue({
        ok: true,
        json: async () => [
          {
            coordinates: 'pkg:npm/foo@1.0.0',
            description: '',
            reference: '',
            vulnerabilities: [],
          },
        ],
      });
      const coords = ['pkg:npm/foo@1.0.0'];
      const result = await (provider as any).dataFromSonaType(coords);
      expect(corsFetch).toHaveBeenCalled();
      expect(result[0].coordinates).toBe('pkg:npm/foo@1.0.0');
    });
    it('should handle fetch errors gracefully', async () => {
      const error = new Error('Failed');
      (corsFetch as jest.Mock).mockRejectedValue(error);
      const errorSpy = jest.spyOn(console, 'error').mockImplementation();
      const coords = ['pkg:npm/foo@1.0.0'];
      const result = await (provider as any).dataFromSonaType(coords);
      expect(errorSpy).toHaveBeenCalledWith(
        'Failed to fetch from Sonatype API:',
        error,
      );
      expect(result).toEqual([]);
    });
    it('should throw on non-ok response', async () => {
      const nonOkResponse = {
        ok: false,
        statusText: 'Bad Request',
        json: async () => [],
      };
      (corsFetch as jest.Mock).mockResolvedValue(nonOkResponse);
      const errorSpy = jest.spyOn(console, 'error').mockImplementation();
      const coords = ['pkg:npm/foo@1.0.0'];
      await expect((provider as any).dataFromSonaType(coords)).resolves.toEqual(
        [],
      );
      expect(errorSpy).toHaveBeenCalledWith(
        'Failed to fetch from Sonatype API:',
        new Error(
          `Failed to fetch vulnerabilities: ${nonOkResponse.statusText}`,
        ),
      );
    });
  });
});
