import {Package} from 'src/packages/types';
import {PackageType} from 'src/packages/types';
import {Severity, Vulnerability, VulnerabilityContainer} from '../types';
import {VulnerabilityProvider} from './types';

/**
 * Abstract base class for vulnerability providers
 *
 * Implements common functionality for adding vulnerability information to packages
 * based on their type and version.
 */
export abstract class AbstractVulnerabilityProvider
  implements VulnerabilityProvider
{
  public packageType: PackageType;

  /**
   * List of package types supported by this provider
   * Must be implemented by concrete classes
   */
  protected abstract readonly supportedPackageTypes: PackageType[];

  /**
   * Retrieves vulnerabilities for the given packages
   * Must be implemented by concrete classes
   *
   * @param packages The packages to check for vulnerabilities
   * @returns A map of packages to their vulnerabilities
   */
  protected abstract getVulnerabilitiesPerPackage(
    packages: Package[],
  ): Promise<Map<Package, Vulnerability[]>>;

  constructor(packageType: PackageType) {
    this.packageType = packageType;
  }

  /**
   * Adds vulnerability information to the provided packages
   *
   * @param packages The packages to add vulnerability information to
   * @returns The packages with added vulnerability information
   */
  async addVulnerabilities(packages: Package[]): Promise<Package[]> {
    if (!packages || packages.length === 0) {
      return packages;
    }

    this.validatePackageType();
    const vulnerabilitiesPerPackage =
      await this.getVulnerabilitiesPerPackage(packages);

    packages.forEach(pkg => {
      this.updatePackageWithVulnerabilityData(
        pkg,
        vulnerabilitiesPerPackage.get(pkg),
      );
    });

    return packages;
  }

  /**
   * Validates that the package type is supported by this provider
   *
   * @throws Error if the package type is not supported
   */
  protected validatePackageType(): void {
    if (!this.supportedPackageTypes.includes(this.packageType)) {
      throw new Error(`Unsupported package type: ${this.packageType}`);
    }
  }

  /**
   * Updates a package with its vulnerability information
   *
   * @param pkg The package to update
   * @param vulnerabilities The vulnerabilities to add to the package
   */
  private updatePackageWithVulnerabilityData(
    pkg: Package,
    vulnerabilities: Vulnerability[] | undefined,
  ): void {
    if (vulnerabilities && vulnerabilities.length > 0) {
      const vulnerabilityContainer =
        this.buildVulnerabilityContainer(vulnerabilities);
      pkg.vulnerabilityContainer = vulnerabilityContainer;
    }
  }

  /**
   * Creates a vulnerability container with overall severity
   *
   * @param vulnerabilities The list of vulnerabilities
   * @returns A vulnerability container with overall severity
   */
  protected buildVulnerabilityContainer(
    vulnerabilities: Vulnerability[],
  ): VulnerabilityContainer {
    const overallScore =
      AbstractVulnerabilityProvider.calculateOverallScore(vulnerabilities);
    const vulnerabilityContainer: VulnerabilityContainer = {
      vulnerabilities: vulnerabilities,
      overallSeverity:
        AbstractVulnerabilityProvider.scoreToSeverity(overallScore),
    };
    return vulnerabilityContainer;
  }

  /**
   * Converts a CVSS score to a severity level
   *
   * @param score The CVSS score (0-10)
   * @returns The corresponding severity level
   */
  protected static scoreToSeverity(score: number): Severity {
    if (score >= 9) return Severity.Critical;
    if (score >= 7) return Severity.High;
    if (score >= 4) return Severity.Medium;
    if (score >= 0) return Severity.Low;
    return Severity.Unknown;
  }

  /**
   * Calculates the overall score for a list of vulnerabilities
   *
   * @param vulnerabilities The list of vulnerabilities
   * @returns The average CVSS score
   */
  protected static calculateOverallScore(
    vulnerabilities: Vulnerability[],
  ): number {
    if (!vulnerabilities || vulnerabilities.length === 0) {
      return 0;
    }
    const sum = vulnerabilities.reduce((acc, vuln) => acc + vuln.cvssScore, 0);
    return sum / vulnerabilities.length;
  }
}
