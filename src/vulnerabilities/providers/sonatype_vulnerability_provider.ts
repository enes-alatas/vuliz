import {Package, PackageType} from 'src/packages/types';
import {AbstractVulnerabilityProvider} from './vulnerability_provider';
import {Vulnerability} from '../types';
import {corsFetch} from 'src/utils/cors_client';

/**
 * Represents vulnerability data from the Sonatype OSS Index API
 */
interface SonaTypeData {
  coordinates: string;
  description: string;
  reference: string;
  vulnerabilities: {
    title: string;
    cvssScore: number;
    cve?: string;
  }[];
}

/**
 * Vulnerability provider implementation using the Sonatype OSS Index API
 *
 * This provider fetches vulnerability data for packages from Sonatype's
 * public vulnerability database and converts them to Vuliz's
 * vulnerability model.
 *
 * The Sonatype API has a limit of 128 coordinates per request,
 * so requests are automatically chunked when needed.
 */
export class SonaTypeVulnerabilityProvider extends AbstractVulnerabilityProvider {
  private readonly apiEndpoint: string;
  private readonly chunkSize: number = 128; // Sonatype API limit per request

  protected readonly supportedPackageTypes: PackageType[] = [
    PackageType.PYPI,
    PackageType.NPM,
  ];

  constructor() {
    super();
    this.apiEndpoint = 'https://ossindex.sonatype.org/api/v3/component-report';
  }

  /**
   * Retrieves vulnerabilities for a batch of packages
   *
   * @param packages The packages to check for vulnerabilities
   * @returns Map of packages to their vulnerabilities
   */
  protected async getVulnerabilitiesPerPackage(
    packages: Package[],
  ): Promise<Map<Package, Vulnerability[]>> {
    if (!packages || packages.length === 0) {
      return new Map<Package, Vulnerability[]>();
    }

    const coordinatePkgMap = this.getCoordinatePkgMap(packages);
    const coordinates = Array.from(coordinatePkgMap.keys());
    const sonatypeResults = await this.dataFromSonaType(coordinates);
    const vulnerabilitiesPerPackage = new Map<Package, Vulnerability[]>();

    sonatypeResults.forEach(resultData => {
      const pkg = coordinatePkgMap.get(resultData.coordinates);
      if (pkg) {
        const vulnerabilities = this.mapVulnerabilities(
          resultData.vulnerabilities || [],
        );
        vulnerabilitiesPerPackage.set(pkg, vulnerabilities);
      }
    });

    return vulnerabilitiesPerPackage;
  }

  /**
   * Fetches vulnerability data from the Sonatype API
   *
   * @param coordinates Package coordinates in Sonatype format
   * @returns Array of vulnerability data
   */
  private async dataFromSonaType(
    coordinates: string[],
  ): Promise<SonaTypeData[]> {
    if (!coordinates || coordinates.length === 0) {
      return [];
    }

    try {
      const allData: SonaTypeData[] = [];

      for (let i = 0; i < coordinates.length; i += this.chunkSize) {
        const chunk = coordinates.slice(i, i + this.chunkSize);
        const response = await corsFetch(
          this.apiEndpoint,
          this.requestOptions(chunk),
        );
        SonaTypeVulnerabilityProvider.checkResponse(response);

        const chunkData = (await response.json()) as SonaTypeData[];
        allData.push(...chunkData);
      }

      return allData;
    } catch (error) {
      console.error('Failed to fetch from Sonatype API:', error);
      // Return empty array if API call fails to maintain graceful degradation
      return [];
    }
  }

  /**
   * Validates that the API response is OK
   *
   * @param response The API response
   * @throws Error if the response is not OK
   */
  private static checkResponse(response: Response): void {
    if (!response.ok) {
      throw new Error(
        `Failed to fetch vulnerabilities: ${response.statusText}`,
      );
    }
  }

  /**
   * Creates request options for the Sonatype API
   *
   * @param coordinates Package coordinates to check
   * @returns Request options for fetch
   */
  private requestOptions(coordinates: string[]): RequestInit {
    return {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: this.buildRequestBody(coordinates),
    };
  }

  /**
   * Builds the request body for the Sonatype API
   *
   * @param coordinates Package coordinates to check
   * @returns JSON string for the request body
   */
  private buildRequestBody(coordinates: string[]): string {
    return JSON.stringify({coordinates});
  }

  /**
   * Maps package objects to their Sonatype coordinate strings
   *
   * @param packages The packages to map
   * @returns Map of coordinate strings to package objects
   */
  private getCoordinatePkgMap(packages: Package[]): Map<string, Package> {
    const map = new Map<string, Package>();

    packages.forEach(pkg => {
      this.validatePackageType(pkg.type);
      const coordinate = `pkg:${pkg.type}/${pkg.name}@${pkg.version}`;
      map.set(coordinate, pkg);
    });

    return map;
  }

  /**
   * Converts Sonatype vulnerabilities to the application's vulnerability model
   *
   * @param rawVulnerabilities Vulnerabilities from Sonatype API
   * @returns Converted vulnerability objects
   */
  private mapVulnerabilities(
    rawVulnerabilities: SonaTypeData['vulnerabilities'],
  ): Vulnerability[] {
    if (!rawVulnerabilities || rawVulnerabilities.length === 0) {
      return [];
    }

    return rawVulnerabilities.map(vulnerability => ({
      name: vulnerability.title,
      cvssScore: vulnerability.cvssScore,
      severity: SonaTypeVulnerabilityProvider.scoreToSeverity(
        vulnerability.cvssScore,
      ),
      cveId: vulnerability.cve,
    }));
  }
}
